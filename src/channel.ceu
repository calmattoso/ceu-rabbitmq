#ifndef _CHANNEL_CEU
#define _CHANNEL_CEU

#include <c.ceu>
#include <uv/uv.ceu>

#include "amqp_base.ceu"
#include "connection.ceu"
#include "handler.ceu"

native/pre do
    amqp_envelope_t new_envelope() {
        amqp_envelope_t msg;
        return msg;
    }
end

native/pure
    _new_envelope,
;

native/nohold
    _amqp_channel_open,
    _amqp_channel_close,
    _amqp_consume_message,
    _amqp_destroy_envelope,
;

data Channel with
    var& Connection conn;
    var  int        id;
end

code/await LowHandler (var _amqp_envelope_t message) -> void
do
  do finalize with
    _amqp_destroy_envelope(&&message);
#ifdef DEBUG
    _printf("Destroyed message with consumer tag `%s`.\n", 
            _stringify_bytes(message.consumer_tag));
#endif
  end
  spawn Handler (message);
end

code/await New_Channel (var& Connection conn, pool&[] LowHandler handlers) 
                            -> (var& Channel ch, event& void ok)
                                -> FOREVER 
do
    // export channel
    var int channel_id = call Next_Channel_Id(&conn);
    var Channel ch_ = val Channel(&conn, channel_id);
    ch = &ch_;

    _printf("Opening channel...");
    event void ok_;
    ok = &ok_;
    await async/thread(ch_) do
        _amqp_channel_open(&&ch_.conn.state, ch_.id);
    end
    _die_on_amqp_error(_amqp_get_rpc_reply(&&ch_.conn.state), "Opening channel");
    emit ok_;

#ifdef DEBUG
    _printf("Opened channel with ID %d!\n", ch_.id);
#endif

    loop do
#ifdef DEBUG
        _printf("Consuming...\n");
#endif
        var _amqp_envelope_t message = _new_envelope();   

        // Get messages received by the channel and dispatch to handlers...
        _printf("Before!\n");
        await async/thread(ch_, message) do
            // amqp_consume_message(amqp_connection_state_t state, amqp_envelope_t *envelope,
            //                      struct timeval *timeout, AMQP_UNUSED int flags)
            _amqp_consume_message(&&ch_.conn.state, &&message, null, 0);
        end

        _printf("Received msg!\n");
        spawn LowHandler (message) in handlers;
    end

   
    do finalize with
        _die_on_amqp_error(_amqp_channel_close(&&ch_.conn.state, ch_.id, _AMQP_REPLY_SUCCESS), "Closing channel");
#ifdef DEBUG
        _printf("Closed channel!\n");
#endif  
    end

    await FOREVER;
end

#ifdef channel_test
var ConnectionContext def_c = _;
par/or do
    var& Connection conn;
    event& void conn_ok;
    pool[] LowHandler handlers;

    spawn New_Connection(def_c) -> (&conn, &conn_ok);
    await conn_ok;

    var& Channel ch;
    event& void chann_ok;
    spawn New_Channel(&conn, &handlers) -> (&ch, &chann_ok);
    await chann_ok;

    _printf("After!\n");
    await 20s;
with
    await 10s;
    _printf("Test over...\n");
end

escape 0;
#endif

#endif
