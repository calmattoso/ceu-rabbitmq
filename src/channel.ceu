#ifndef _CHANNEL_CEU
#define _CHANNEL_CEU

#include "connection.ceu"

class Channel with
  var Connection& conn;
output:
  var int id;
do
  native do
    ##include <stdlib.h>
    ##include <stdio.h>
    ##include <string.h>
    ##include <stdint.h>
    
    ##include <amqp_tcp_socket.h>
    ##include <amqp.h>
    ##include <amqp_framing.h>

    ##include "utils.c"
  end

  // prototype hacks
  native @nohold  _amqp_get_rpc_reply;
  native @nohold  _amqp_channel_open;
  native @nohold  _amqp_channel_close;
  native @plain _amqp_connection_state_t_;

  // protected variables
  this.id = conn.next_channel_id();
  conn.inc_channel_id();

  // body
    _amqp_channel_open(&&conn.state, id);

  // this.conn.open_channel(&this);
  ///finalize with
    // this.conn.close_channel(&this);

    _die_on_amqp_error(_amqp_get_rpc_reply(&&conn.state), "Opening channel");
    _printf("Opened channel!\n");
    finalize with
      _die_on_amqp_error(_amqp_channel_close(&&conn.state, id, _AMQP_REPLY_SUCCESS), "Closing channel");
      _printf("Closed channel!\n");
    end
  await FOREVER;
end

#if 0
// little test
input void TEST_CLOSE;
par/or do
  var Connection c with
    this.hostname = [] .. "localhost";
    this.port = 5672;
    this.vhost = [] .. "/";
    this.channel_max = 0;
    this.frame_max = 131072;
    this.sasl_method = _AMQP_SASL_METHOD_PLAIN;
    this.user = [] .. "guest";
    this.password = [] .. "guest";
  end;


//pool Channel[5] chs; //segfault
  watching c do
    #if 1  
    var Channel ch with
      this.conn = &c;
    end;
    _printf("Channel ID: %d\n", ch.id);

    var Channel ch2 with
      this.conn = &c;
    end;
    _printf("Channel ID: %d\n", ch2.id);
    #endif

    #if 0
    // Segfault:
    // =========
    loop i in 5 do
      var Channel&&? ch =
        spawn Channel in chs with
          this.conn = &c;
        end;
      _printf("Channel ID: %d\n", ch!:id);
    end
    #endif

    await TEST_CLOSE;
  end
with
  async do
    emit TEST_CLOSE;
  end
end

escape 0;
#endif

#endif
