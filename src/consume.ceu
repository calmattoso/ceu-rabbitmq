#ifndef _PUBLISH_CEU
#define _PUBLISH_CEU

#include "connection.ceu"
#include "channel.ceu"
#include "q2x_bind.ceu"
#include "exchange.ceu"
#include "queue.ceu"

class Consume with
  event void consume;
  event _amqp_envelope_t receive;
input:
  var Channel& channel;
  var Queue& queue;
  var bool no_local;
  var bool no_ack;
  var bool exclusive;
  var _amqp_table_t arguments;
do
  native/pre do
    ##include <stdlib.h>
    ##include <stdio.h>
    ##include <string.h>
    ##include <stdint.h>
    
    ##include <amqp_tcp_socket.h>
    ##include <amqp.h>
    ##include <amqp_framing.h>

    ##include "utils.c"
  end

  // prototype hacks
  native @plain   _amqp_boolean_t; // this is an `int`
  native @plain   _amqp_basic_properties_t;   // properties for basic methods
  native @plain   _amqp_bytes_t;   // amqp representation for strings; `struct` with inner bytes pointer: https://git.io/vrcWN
  native @plain   _amqp_table_t;   // arguments for method; simple `struct` with inner pointer: https://git.io/vrcW9
  native @plain   _amqp_rpc_reply_t;
  native @plain   _amqp_envelope_t; // message envelope. `struct` with inner pointer
  native @pure    _amqp_basic_consume;
  native @pure    _amqp_consume_message;
  native @pure    _amqp_cstring_bytes; // no `malloc` is done internally, it just points to `char*` as `void*`
  native @pure    _amqp_dump;
  native @nohold  _amqp_destroy_envelope; // immediately destroys the internal message buffer
  native @nohold  _amqp_get_rpc_reply;
  native @nohold  _stringify_bytes;

  // BODY:
  // First, set the channel to message consumption mode.
  // amqp_basic_consume_ok_t *
  // AMQP_CALL amqp_basic_consume(amqp_connection_state_t state, amqp_channel_t channel,
  //                              amqp_bytes_t queue, amqp_bytes_t consumer_tag, 
  //                              amqp_boolean_t no_local, amqp_boolean_t no_ack,
  //                              amqp_boolean_t exclusive, amqp_table_t arguments)
  _amqp_basic_consume(&&channel.conn.state, channel.id, queue.name_bytes, 
                     _amqp_empty_bytes, (_amqp_boolean_t) no_local, 
                     (_amqp_boolean_t) no_ack, (_amqp_boolean_t) exclusive, 
                     arguments);
  _die_on_amqp_error(_amqp_get_rpc_reply(&&channel.conn.state), "Failed to put channel in consume mode.");

  var _amqp_rpc_reply_t res = _amqp_rpc_reply_t();
  var _amqp_envelope_t  message = _amqp_envelope_t();

  //await this.consume;
  _printf("Consuming...\n");

  //loop do   
    // Get messages from queue we're listening to.
    //async/thread (channel, message) do
        // amqp_consume_message(amqp_connection_state_t state, amqp_envelope_t *envelope,
        //                      struct timeval *timeout, AMQP_UNUSED int flags)
        _amqp_consume_message(&&this.channel.conn.state, &&message, _NULL, 0);
    //end
    _amqp_dump(message.message.body.bytes, message.message.body.len);
    // check if the consume call was successful
    //if _AMQP_RESPONSE_NORMAL != _res.reply_type then
    //  break;
    //end
    
    //emit this.receive => message;
    _amqp_destroy_envelope(&&message);
  //end
end


#if 0
// little test
  var Connection c with
    this.hostname = [] .. "localhost";
    this.port = 5672;
    this.vhost = [] .. "/";
    this.channel_max = 0;
    this.frame_max = 131072;
    this.sasl_method = _AMQP_SASL_METHOD_PLAIN;
    this.user = [] .. "guest";
    this.password = [] .. "guest";
  end;

  watching c do
    var Channel ch with
      this.conn = &c;
    end;
    _printf("Channel ID: %d\n", ch.id);

    watching ch do
      var Queue q with
        this.channel = &ch;
        this.name = [].."test_queue";
        this.passive = false;
        this.durable = false;
        this.exclusive = false;
        this.auto_delete = true;
        this.arguments = _amqp_empty_table;
      end;
      _printf("Created Queue with name '%s'.\n", _stringify_bytes(q.name_bytes));

      var Exchange amq_direct with
        this.channel = &ch;
        this.name = [].."amq.direct";
        this.type = [].."direct";
        this.passive = false;
        this.durable = true;
        this.auto_delete = false;
        this.internal = false;
        this.arguments = _amqp_empty_table;
      end;
      _printf("Using default direct exchange 'amq.direct'.\n");

			var Q2X_Bind bind with
        this.channel  = &ch;
				this.queue    = &q;
				this.exchange = &amq_direct;
        this.binding_key = [].."test";
        this.arguments = _amqp_empty_table;
			end;
      _printf("Successfully bound Queue to Exchange.\n");

      //watching (q, amq_direct, bind) do
        loop do
          var Consume com with
            this.channel = &ch;
            this.queue = &q;
            this.no_local = false;
            this.no_ack = true;
            this.exclusive = false;
            this.arguments = _amqp_empty_table;
          end;

          /*par/and do
            var _amqp_envelope_t msg = await com.receive;
            _printf("Received message!\n");
            _amqp_dump(msg.message.body.bytes, msg.message.body.len);
            _printf("1");
          with
             _printf("2");
            emit com.consume; 
          end*/
        end
      //end
    end
  end

escape 0;
#endif

#endif
